name: Build MagicKeyRevC

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:  # Allow manual trigger

jobs:
  build:
    runs-on: windows-latest
    permissions:
      contents: write
      actions: read
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup MSYS2
      uses: msys2/setup-msys2@v2
      with:
        msystem: UCRT64
        update: true
        install: >-
          mingw-w64-ucrt-x86_64-gcc
          mingw-w64-ucrt-x86_64-openssl
          mingw-w64-ucrt-x86_64-pkg-config
          make
    
    - name: Install additional dependencies
      shell: bash
      run: |
        # Ensure we have latest packages and essential Windows dependencies
        echo "Installing additional dependencies..."
        
        # Check what Visual C++ redistributables are available
        echo "Available VC++ redistributables:"
        ls -la "/c/Program Files/Microsoft Visual Studio/" 2>/dev/null || echo "Visual Studio not found"
        ls -la "/c/Program Files (x86)/Microsoft Visual Studio/" 2>/dev/null || echo "Visual Studio x86 not found"
    
    - name: Create config.h from secrets
      shell: bash
      run: |
        # Always create a fresh config.h to avoid secret masking issues
        echo "Creating clean config.h file"
        
        # Create base config with echo commands to avoid YAML issues
        echo '#pragma once' > config.h
        echo '#include <string>' >> config.h
        echo '' >> config.h
        echo 'namespace Config {' >> config.h
        echo '    static const std::string IPCHECK_URL = "https://ipcheck.siu4.workers.dev/";' >> config.h
        echo '    static const std::string PROXYCHECK_URL = "https://proxycheck.io/v2/";' >> config.h
        
        # Add BACKEND_URL (with secret if available)
        if [ "${{ github.event_name }}" != "pull_request" ] && [ -n "${{ secrets.BACKEND_URL }}" ]; then
          echo "    static const std::string BACKEND_URL = \"${{ secrets.BACKEND_URL }}\";" >> config.h
        else
          echo '    static const std::string BACKEND_URL = "https://example.com/api";' >> config.h
        fi
        
        # Add LOGIN_BASE_URL (with secret if available)
        if [ "${{ github.event_name }}" != "pull_request" ] && [ -n "${{ secrets.LOGIN_BASE_URL }}" ]; then
          echo "    static const std::string LOGIN_BASE_URL = \"${{ secrets.LOGIN_BASE_URL }}\";" >> config.h
        else
          echo '    static const std::string LOGIN_BASE_URL = "https://example.com/login";' >> config.h
        fi
        
        # Add USER_AGENT (with secret if available)
        if [ "${{ github.event_name }}" != "pull_request" ] && [ -n "${{ secrets.USER_AGENT }}" ]; then
          echo "    static const std::string USER_AGENT = \"${{ secrets.USER_AGENT }}\";" >> config.h
        else
          echo '    static const std::string USER_AGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) WebView2";' >> config.h
        fi
        
        echo '    static const int TIMEOUT_MS = 30000;' >> config.h
        echo '    static const int RETRY_ATTEMPTS = 3;' >> config.h
        echo '    static const std::string PUBLIC_KEY_FILE = "";' >> config.h
        echo '    static const bool USE_EMBEDDED_KEY = true;' >> config.h
        echo '    static const bool DISABLE_DEVTOOLS = true;' >> config.h
        echo '    static const bool DISABLE_CONTEXT_MENU = true;' >> config.h
        echo '    static const bool DISABLE_TEXT_SELECTION = true;' >> config.h
        echo '    static const bool DISABLE_COPY_PASTE = true;' >> config.h
        echo '    static const std::string APP_VERSION = "1.01C";' >> config.h
        echo '    static const std::string APP_NAME = "MagicKeyRevC";' >> config.h
        
        # Add DCID (with secret if available)
        if [ "${{ github.event_name }}" != "pull_request" ] && [ -n "${{ secrets.DCID }}" ]; then
          echo "    static const std::string DCID = \"${{ secrets.DCID }}\";" >> config.h
        else
          echo '    static const std::string DCID = "default";' >> config.h
        fi
        
        echo '    static const int WINDOW_WIDTH = 900;' >> config.h
        echo '    static const int WINDOW_HEIGHT = 700;' >> config.h
        echo '    static const bool DEBUG_ENABLED = false;' >> config.h
        echo '    static const bool LOG_ENCRYPTED_DATA = false;' >> config.h
        echo '    static const bool LOG_SERVER_RESPONSES = false;' >> config.h
        echo '    static const bool LOG_SYSTEM_INFO = false;' >> config.h
        echo '}' >> config.h
        echo '' >> config.h
        
        # Add compatibility class (simpler approach)
        echo 'class ConfigCompat {' >> config.h
        echo 'public:' >> config.h
        echo '    std::string get_ipcheck_url() { return Config::IPCHECK_URL; }' >> config.h
        echo '    std::string get_proxycheck_url() { return Config::PROXYCHECK_URL; }' >> config.h
        echo '    std::string get_backend_url() { return Config::BACKEND_URL; }' >> config.h
        echo '    std::string get_login_base_url() { return Config::LOGIN_BASE_URL; }' >> config.h
        echo '    std::string get_user_agent() { return Config::USER_AGENT; }' >> config.h
        echo '    std::string get_public_key_file() { return Config::PUBLIC_KEY_FILE; }' >> config.h
        echo '    std::string get_app_version() { return Config::APP_VERSION; }' >> config.h
        echo '    std::string get_app_name() { return Config::APP_NAME; }' >> config.h
        echo '    std::string get_dcid() { return Config::DCID; }' >> config.h
        echo '    int get_window_width() { return Config::WINDOW_WIDTH; }' >> config.h
        echo '    int get_window_height() { return Config::WINDOW_HEIGHT; }' >> config.h
        echo '    int get_timeout_ms() { return Config::TIMEOUT_MS; }' >> config.h
        echo '    int get_retry_attempts() { return Config::RETRY_ATTEMPTS; }' >> config.h
        echo '    bool is_debug_enabled() { return Config::DEBUG_ENABLED; }' >> config.h
        echo '    bool should_log_encrypted_data() { return Config::LOG_ENCRYPTED_DATA; }' >> config.h
        echo '    bool should_log_server_responses() { return Config::LOG_SERVER_RESPONSES; }' >> config.h
        echo '    bool should_log_system_info() { return Config::LOG_SYSTEM_INFO; }' >> config.h
        echo '    bool should_disable_devtools() { return Config::DISABLE_DEVTOOLS; }' >> config.h
        echo '    bool should_disable_context_menu() { return Config::DISABLE_CONTEXT_MENU; }' >> config.h
        echo '    bool should_disable_text_selection() { return Config::DISABLE_TEXT_SELECTION; }' >> config.h
        echo '    bool should_disable_copy_paste() { return Config::DISABLE_COPY_PASTE; }' >> config.h
        echo '};' >> config.h
        echo '' >> config.h
        echo 'extern ConfigCompat* g_config;' >> config.h
        echo '' >> config.h
        echo 'inline void init_config(const std::string& config_file = "") {' >> config.h
        echo '    if (!g_config) {' >> config.h
        echo '        g_config = new ConfigCompat();' >> config.h
        echo '    }' >> config.h
        echo '}' >> config.h
        echo '' >> config.h
        echo 'inline void cleanup_config() {' >> config.h
        echo '    if (g_config) {' >> config.h
        echo '        delete g_config;' >> config.h
        echo '        g_config = nullptr;' >> config.h
        echo '    }' >> config.h
        echo '}' >> config.h
        
        echo "Config.h created successfully"
    
    - name: Verify build environment
      shell: msys2 {0}
      run: |
        echo "Checking build environment..."
        echo "GCC version:"
        gcc --version
        echo "Available DLLs in /ucrt64/bin:"
        ls -la /ucrt64/bin/libgcc* /ucrt64/bin/libstdc* /ucrt64/bin/libwinpthread* /ucrt64/bin/libssl* /ucrt64/bin/libcrypto* 2>/dev/null || echo "Some DLLs not found"
        echo "WebView2 files in workspace:"
        ls -la WebView2* lib* 2>/dev/null || echo "Some WebView2 files not found"
    
    - name: Create public_key.pem from secrets
      shell: bash
      run: |
        if [ -n "${{ secrets.PUBLIC_KEY_PEM }}" ]; then
          echo "${{ secrets.PUBLIC_KEY_PEM }}" > public_key.pem
        else
          echo "Warning: PUBLIC_KEY_PEM secret not set"
          if [ -f "public_key.pem.example" ]; then
            cp public_key.pem.example public_key.pem
            echo "Using public_key.pem.example"
          elif [ ! -f "public_key.pem" ]; then
            echo "Creating dummy public_key.pem"
            echo "-----BEGIN PUBLIC KEY-----" > public_key.pem
            echo "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1234567890abcdef" >> public_key.pem
            echo "1234567890abcdef1234567890abcdef1234567890abcdef1234567890ab" >> public_key.pem
            echo "cdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890" >> public_key.pem
            echo "abcdef1234567890abcdef1234567890abcdef1234567890abcdef12345678" >> public_key.pem
            echo "90abcdef1234567890abcdef1234567890abcdef1234567890abcdef123456" >> public_key.pem
            echo "7890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234" >> public_key.pem
            echo "QIDAQAB" >> public_key.pem
            echo "-----END PUBLIC KEY-----" >> public_key.pem
          fi
        fi
    
    - name: Embed public key in source code
      shell: bash
      run: |
        echo "Embedding public key in source code..."
        
        # Create embedded_key.h with the public key as a string constant
        echo '#pragma once' > embedded_key.h
        echo '#include <string>' >> embedded_key.h
        echo '' >> embedded_key.h
        echo 'namespace EmbeddedKey {' >> embedded_key.h
        echo '    static const std::string PUBLIC_KEY_PEM = R"(' >> embedded_key.h
        cat public_key.pem >> embedded_key.h
        echo ')";' >> embedded_key.h
        echo '}' >> embedded_key.h
        
        echo "Public key embedded successfully"
        echo "Embedded key file preview:"
        head -10 embedded_key.h
    
    - name: Build application
      shell: msys2 {0}
      run: |
        echo "Starting compilation..."
        # Use more robust linking to match local build
        g++ -O2 -s -static-libgcc -static-libstdc++ *.cpp \
          -o main.exe \
          -lole32 -loleaut32 -lwbemuuid -lwininet \
          -lssl -lcrypto -lbcrypt -lcrypt32 -lgdi32 -lws2_32 \
          -L. -I./include \
          ./WebView2Loader.dll.lib
        
        echo "Build completed. Checking executable..."
        if [ -f "main.exe" ]; then
          echo "main.exe created successfully"
          ls -la main.exe
          
          # Check dependencies
          echo "Checking dependencies:"
          objdump -p main.exe | grep "DLL Name" | head -20 || echo "Could not check dependencies"
        else
          echo "Error: main.exe not found after compilation"
          exit 1
        fi
    
    - name: Create distribution package
      shell: bash
      run: |
        mkdir -p dist
        cp main.exe dist/
        
        # Copy WebView2 files (must match local build exactly)
        echo "Copying WebView2 files..."
        cp WebView2Loader.dll dist/ && echo "âœ“ Copied WebView2Loader.dll" || echo "âœ— Failed to copy WebView2Loader.dll"
        cp WebView2LoaderStatic.lib dist/ && echo "âœ“ Copied WebView2LoaderStatic.lib" || echo "âœ— Failed to copy WebView2LoaderStatic.lib"
        cp libWebView2Loader.a dist/ && echo "âœ“ Copied libWebView2Loader.a" || echo "âœ— Failed to copy libWebView2Loader.a"
        
        # Find the correct MSYS2 paths first
        echo "Locating MSYS2 DLL paths..."
        MSYS2_BIN=""
        for path in "/ucrt64/bin" "/mingw64/bin" "/usr/bin" "C:/msys64/ucrt64/bin" "C:/msys64/mingw64/bin"; do
          if [ -d "$path" ] && [ -f "$path/libgcc_s_seh-1.dll" ]; then
            MSYS2_BIN="$path"
            echo "Found MSYS2 binaries at: $MSYS2_BIN"
            break
          fi
        done
        
        if [ -z "$MSYS2_BIN" ]; then
          echo "Searching for MinGW DLLs in common locations..."
          find /c/msys64 -name "libgcc_s_seh-1.dll" 2>/dev/null | head -5
          find /d/a/_temp/msys64 -name "libgcc_s_seh-1.dll" 2>/dev/null | head -5
          find /mingw64 -name "libgcc_s_seh-1.dll" 2>/dev/null | head -5
          
          # Try alternative paths that might exist in GitHub Actions
          for alt_path in "/d/a/_temp/msys64/ucrt64/bin" "/c/msys64/ucrt64/bin" "/msys64/ucrt64/bin"; do
            if [ -d "$alt_path" ] && [ -f "$alt_path/libgcc_s_seh-1.dll" ]; then
              MSYS2_BIN="$alt_path"
              echo "Found alternative MSYS2 path: $MSYS2_BIN"
              break
            fi
          done
        fi
        
        if [ -z "$MSYS2_BIN" ]; then
          echo "ERROR: Could not locate MSYS2 binary directory!"
          echo "Available paths:"
          ls -la /ucrt64/ 2>/dev/null || echo "No /ucrt64/"
          ls -la /mingw64/ 2>/dev/null || echo "No /mingw64/"
          ls -la /c/msys64/ 2>/dev/null || echo "No /c/msys64/"
          exit 1
        fi
        
        # Copy MinGW runtime DLLs (must match local build exactly)
        echo "Copying MinGW runtime DLLs from $MSYS2_BIN..."
        cp "$MSYS2_BIN/libgcc_s_seh-1.dll" dist/ && echo "âœ“ Copied libgcc_s_seh-1.dll" || echo "âœ— Failed to copy libgcc_s_seh-1.dll"
        cp "$MSYS2_BIN/libstdc++-6.dll" dist/ && echo "âœ“ Copied libstdc++-6.dll" || echo "âœ— Failed to copy libstdc++-6.dll"
        cp "$MSYS2_BIN/libwinpthread-1.dll" dist/ && echo "âœ“ Copied libwinpthread-1.dll" || echo "âœ— Failed to copy libwinpthread-1.dll"
        
        # Copy OpenSSL DLLs (must match local build exactly)
        echo "Copying OpenSSL DLLs from $MSYS2_BIN..."
        cp "$MSYS2_BIN/libssl-3-x64.dll" dist/ && echo "âœ“ Copied libssl-3-x64.dll" || echo "âœ— Failed to copy libssl-3-x64.dll"
        cp "$MSYS2_BIN/libcrypto-3-x64.dll" dist/ && echo "âœ“ Copied libcrypto-3-x64.dll" || echo "âœ— Failed to copy libcrypto-3-x64.dll"
        
        # Note: embedded_key.h is compiled into the executable, no separate .pem file needed
        
        # Verify ALL files from local build are present
        echo "Verifying distribution matches local build..."
        expected_files=(
          "main.exe"
          "WebView2Loader.dll"
          "WebView2LoaderStatic.lib"
          "libWebView2Loader.a"
          "libgcc_s_seh-1.dll"
          "libstdc++-6.dll"
          "libwinpthread-1.dll"
          "libssl-3-x64.dll"
          "libcrypto-3-x64.dll"
        )
        
        missing_files=()
        for file in "${expected_files[@]}"; do
          if [ -f "dist/$file" ]; then
            size=$(stat -c%s "dist/$file" 2>/dev/null || echo "unknown")
            echo "âœ“ $file present ($size bytes)"
          else
            echo "âœ— $file MISSING!"
            missing_files+=("$file")
          fi
        done
        
        if [ ${#missing_files[@]} -eq 0 ]; then
          echo "âœ… All required files present - distribution matches local build!"
        else
          echo "âŒ Missing files: ${missing_files[*]}"
          echo "Distribution is incomplete!"
          
          # Debug: List what's actually available
          echo "Debug: Available DLLs in $MSYS2_BIN:"
          ls -la "$MSYS2_BIN"/lib*.dll 2>/dev/null | head -10
          exit 1
        fi
        
        # List final distribution contents
        echo "Final distribution contents:"
        ls -la dist/
        
        # Check dependencies of the built executable
        echo "Dependencies of main.exe:"
        objdump -p dist/main.exe | grep "DLL Name" | head -20 || echo "Could not check dependencies"
    
    - name: Create ZIP package for release
      shell: bash
      run: |
        echo "Creating ZIP package for release..."
        
        # Get version info for ZIP name
        APP_VERSION=$(grep -o 'APP_VERSION = "[^"]*"' config.h | cut -d'"' -f2 || echo "1.01C")
        TIMESTAMP=$(date +'%Y%m%d-%H%M')
        ZIP_NAME="MagicKeyRevC-v${APP_VERSION}-${TIMESTAMP}"
        
        echo "Creating ${ZIP_NAME}.zip"
        
        # Create ZIP file with all distribution files
        cd dist
        zip -r "../${ZIP_NAME}.zip" .
        cd ..
        
        # Verify ZIP contents
        echo "ZIP package contents:"
        unzip -l "${ZIP_NAME}.zip"
        
        # Get ZIP file size
        ZIP_SIZE=$(stat -c%s "${ZIP_NAME}.zip" 2>/dev/null || echo "unknown")
        echo "ZIP package size: $ZIP_SIZE bytes"
        
        # Move ZIP to dist folder for release
        mv "${ZIP_NAME}.zip" dist/
        
        echo "Release package ready: dist/${ZIP_NAME}.zip"
    
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: MagicKeyRevC-${{ github.sha }}
        path: dist/
        retention-days: 30
    
    - name: Get current date and time
      if: github.ref == 'refs/heads/main' && github.event_name == 'push'
      id: datetime
      shell: bash
      run: |
        echo "tag=v$(date +'%Y.%m.%d-%H%M')" >> $GITHUB_OUTPUT
        echo "name=MagicKeyRevC-$(date +'%Y.%m.%d-%H%M')" >> $GITHUB_OUTPUT
    
    - name: Create tag and release
      if: github.ref == 'refs/heads/main' && github.event_name == 'push'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        TAG_NAME: ${{ steps.datetime.outputs.tag }}
        REPO_NAME: ${{ github.repository }}
      run: |
        # Configure git with token authentication
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
        # Debug: Show what we're working with
        echo "Creating tag: ${TAG_NAME}"
        echo "Repository: ${REPO_NAME}"
        
        # Create tag
        git tag "${TAG_NAME}"
        
        # Push tag using token authentication
        git remote set-url origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${REPO_NAME}.git"
        git push origin "${TAG_NAME}"
        
        # Verify tag was created successfully
        if git ls-remote --tags origin | grep -q "${TAG_NAME}"; then
          echo "Tag ${TAG_NAME} successfully created and pushed"
          echo "tag_created=true" >> $GITHUB_OUTPUT
        else
          echo "Failed to create or push tag"
          exit 1
        fi
      id: create_tag
    
    - name: Create Release
      if: github.ref == 'refs/heads/main' && github.event_name == 'push' && steps.create_tag.outputs.tag_created == 'true'
      uses: softprops/action-gh-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        TAG_NAME: ${{ steps.datetime.outputs.tag }}
        RELEASE_NAME: ${{ steps.datetime.outputs.name }}
      with:
        tag_name: ${{ env.TAG_NAME }}
        name: ${{ env.RELEASE_NAME }}
        body: |
          **ðŸ“¦ MagicKeyRevC Release Package**
          
          **Download**: Get the complete ZIP package below - contains everything you need to run the application!
          
          **What's Included:**
          - âœ… `main.exe` - Ready-to-run executable (embedded key, no .pem file needed)
          - âœ… All required runtime DLLs (OpenSSL, MinGW, WebView2)
          - âœ… Complete dependency package
          
          **System Requirements:**
          - Windows 10/11 (x64)
          - No additional installations required
          
          **Usage:**
          1. Download the ZIP file
          2. Extract to any folder
          3. Run `main.exe`
          
          ---
          **Build Info:**
          - Built from commit: `${{ github.sha }}`
          - Branch: `${{ github.ref_name }}`
          - Version: MagicKeyRevC v1.01C
          - Embedded encryption key: âœ… Included
          
        files: |
          dist/*.zip
          dist/main.exe
        draft: false
        prerelease: false
    
    - name: Create Release (on manual tag)
      if: startsWith(github.ref, 'refs/tags/')
      uses: softprops/action-gh-release@v1
      with:
        files: |
          dist/*.zip
          dist/main.exe
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
